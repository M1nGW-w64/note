# <center> 中央处理器 <center/>

## 1. CPU概述

1. 数据通路：指令执行过程中数据所经过的路径，包括路径上的部件。

2. 运算器：

    | 运算器部件 | ALU              | PSW                              | ACC               | 暂存寄存器           | 通用寄存器组             | 移位器           | 计数器             |
    |:------------:|:------------------:|:----------------------------------:|:-------------------:|:----------------------:|:--------------------------:|:------------------:|:--------------------:|
    | 功能       | 算术逻辑运算     | 保存运算状态字信息、测试指令结果 | 暂存ALU的运算结果 | 暂存从主存读出的信息 | 存放操作数和各种地址信心 | 移位运算         | 控制乘除法操作步数 |
    | 可见否     | 所有程序员不可见 | 所有程序员可见                   | 所有程序员不可见  | 对应用程序员不可见   | 所有程序员可见           | 所有程序员不可见 | 所有程序员不可见   |
3. 控制器：

    | 控制器部件 | PC                   | IR                 | ID                 | MAR                | MDR                  | 时序系统         | 微操作信号发生器 |
    |:------------:|:----------------------:|:--------------------:|:--------------------:|:--------------------:|:----------------------:|:------------------:|:------------------:|
    | 功能       | 下一条指令的存放地址 | 保存当前执行的指令 | 对指令的操作码译码 | 存放访存的单元地址 | 存放读写存储器的信息 | 产生时序信号     | 产生控制信号     |
    | 可见否     | 汇编程序员可见       | 所有程序员不可见   | 所有程序员不可见   | 所有程序员不可见   | 所有程序员不可见     | 所有程序员不可见 | 所有程序员不可见 |

## 2. 数据通路

1. 数据通路：**数据在功能部件之间传送的路径叫做数据通路，包括数据通路上流经的部件**如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。
   ```
   数据通路由控制部件控制，因此数据通络不包括控制信号。
   ```

2. 运算、条件分支、load、store指令的数据通路：
3. 基本的MIPS数据通路：
   1. 特点：
      - 仅有load需要结果写回。

      - 大部分指令都需要经过取址、译码、执行、访存、写回五个阶段。

   2. MIPS使用了固定字段译码技术：译码的时候会准备所有的源操作数，ALU没有用到的源操作数直接丢弃。

## 3. 单周期控制器

1. 微操作
   1. 定义：一个部件能够完成的基本操作称为微操作。计算机中所有的操作均可分解位不同微操作的序列。**这些微操作不可再分**。微操作可由寄存器传输语言RTL描述。

   2. 四个基本操作：
      - 内存 -> 寄存器：取数操作、load访存操作。

      - 寄存器 -> 内存：store访存操作。
      - 寄存器 -> 寄存器，或寄存器 -> ALU：译码、add结果写回和load结果写回。
      - 运算结果 -> 寄存器：在ALU单元上运算的指令。
      ```
      上述每个基本操作的执行时间都是一个机器周期，一条指令的指令周期由多个机器周期组成。每条指令都有取址阶段，称为取址周期。剩下的机器周期所完成的功能统称为执行周期。
      ```
   3. 微操作格式：

      |`R[r]`|`M[addr]`|`<-`|`PC`|`OP[data]`|
      |:----:|:-------:|:--:|:--:|:--------:|
      |寄存器的内容|地址为addr的主存单元的内容|数据传送，右边为远寄存器|程序计数器的值|对data进行OP操作|
   4. 控制信号：由于**一个功能部件**可以**完成多个微操作**，因此需要输入外部信号**区分不同的微操作**。
      - 寄存器（完成读、写操作）：输入`RegWr`信号进行区分。**1-写寄存器**，**0-读寄存器**。

      - 存储器（完成读、写操作）：输入`MemWr`信号进行区分。**1-写存储器**，**0-读寄存器**。
      - ALU（完成算术运算、逻辑运算）：输入`ALUctr`区分。
      - MUX（多选一）：比如`RegDst、ALUsrc`等。

2. 设计问题
   1. 数据通路设计问题：
      - 一条指令由哪些微操作完成？（ADD：内存->寄存器（取址、取数）、寄存器->寄存器、运算）

      - 一条指令按什么顺序完成这些微操作？（取址、译码、运算、写回）。

   2. 控制器设计问题：简单来说就是为**不同的指令**生成**每个周期的控制信号**。
      - 一个功能单元执行哪些微操作？

      - 在某个机器周期，功能单元执行哪个微操作？ 
3. 单周期处理器控制器的设计
   ```
   不要求
   ```
4. 单周期处理器的性能
   1. 单周期处理器的CPI为1。但不意味着单周期处理器性能好。因为CPU性能还与时钟周期有关。

   2. 单周期处理器的时钟周期：以**最复杂指令的执行时间**为准。

## 4. 多周期控制器

1. 设计思想：
   1. 单周期处理器的问题：时钟周期过长。

   2. 把指令分成多个阶段，**每个阶段都在一个时钟周期内完成**。
      - 每个阶段的完成时间应尽可能相同。

      - 每个阶段最多只完成一次访存、读写寄存器、ALU运算。
      - 尽可能分成大致相等的若干阶段。

   3. 把**每个阶段的结果**保存在**专用的内部寄存器**中。 

2. 多周期处理器的功能描述方式：
   1. 有限状态机（硬布线控制）：采用组合逻辑设计方法通过硬布线实现。

   2. 微程序控制：下一节介绍。
   3. 微程序控制和硬布线控制方式的对比

      ||工作原理|执行速度|规整性|应用|扩展性|
      |:-:|:-:|:-:|:-:|:-:|:-:|
      |微程序|控制信号以微程序的形式存在控存，执行时读出|慢|比较规整|CISC|易扩充修改|
      |硬布线|控制信号由逻辑电路实时产生|快|繁琐，不规整|RISC|不易扩充修改|
   4. 微程序控制和硬布线控制的优缺点

      ||优点|缺点|
      |:--:|:--:|:--:|
      |微程序|控制器速度取决于电路延迟，速度快|控制器速度取决于电路延迟，速度快|
      |硬布线|控制器速度取决于电路延迟，速度快|控制部件用专门固定时序的逻辑电路制作，一经设计不能额外变动|
3. 多周期处理器的特点：
   1. 指令分为五个阶段，顺序执行。

   2. 同一阶段内的操作可以同时发生。
   3. 每个阶段的结果保存在内部寄存器中。
   4. 优点：
      - 时钟周期短。

      - 不同指令所用周期数可以不同。
      - 功能部件在执行过程中可重用。

4. 多周期处理器的性能
   1. 多周期处理器的CPI：$\bm{CPI = \cfrac{时钟周期数}{指令数} = \sum\cfrac{指令数_i\times CPI_i}{指令数} = \sum(\cfrac{指令数_i}{指令数}\times CPI_i)}$

   2. 多周期处理器和单周期处理器的性能比较：**尽管多周期的CPI变大了，但是其时钟周期也相应缩短了**。
5. 单周期和多周期对比
   1. 周期处理器和多周期处理器的共同点：指令独占整个数据通路直到执行结束。

   2. 单周期处理器和多周期处理器的不同点：多周期处理器中很多控制信号会在执行过程中发生改变，而单周期处理器中控制信号由指令类型确定且在执行时不变化。

## 5. 微程序控制

1. 微程序概述
   1. 描述：将微操作用微指令表示，固化在**控制存储器CM中**。为每条机器指令编制一个微程序。通过执行微程序完成机器指令的执行。
      ```
      CM由ROM实现。
      ```

   2. 设计思想：
      - 仿照程序设计思想，编写机器指令对应的微程序。

      - **若干位微命令构成一条微指令，若干条微指令构成一个微程序**。
      - 执行某条指令时，从该指令对应的**微程序**中取出**微指令**，对**微指令**译码得到**微命令**。得到微命令相当于控制信号。
   3. 相关概念：微程序、微命令、微指令、微操作、微指令周期：
   4. 微程序、微命令、微指令、微操作的关系：

2. Wilkes模型
   1. 微程序控制器的构成：
      1. 指令寄存器`IR`：用来保存正在执行的指令。

      2. 微程序顺序控制逻辑`uC`：决定该机器指令对应的微程序，及微程序第一条微指令的首地址。
      3. 访问地址控制部件`FCMAR`：获取下一条要执行的微指令的地址。

      ```
      这里**微指令**被分为**控制信号字段**和**微地址码字段**。前者用于生成控制信号，后者送到`FCMAR`中生成下一条微指令的地址。
      ```

   2. 微程序控制器的工作过程：
      1. 从`IR`中取出指令的操作码，并送至`FCAMR`、`FCMAR生成CM地址`。

      2. 从控存中取微指令，并生成控制信号字段。
      3. 微地址码字段送回`FCMAR`。

3. 微程序控制器设计
   1. 微指令格式：`uOP[uADD][常数]`。其中微操作码`uOP`必选，微地址码`uADD`可选。

   2. 微操作码编码方式：

      |方法|描述|优点|缺点|
      |:-:|:-:|:--:|:-:|
      |不译法|一位对应一个微命令,<br>微操作码的长度与所有微命令的个数相当|并行控制能力强、控制电路简单、速度快|微指令字实现困难，编码空间利用率低|
      |字段直接编码|将微指令分为若干字段，每个字段包含若干微命令,<br>对每一字段内的微操作编码|较高的并行控制能力、<br>速度快、微指令字段较短、节省控存容量|增加了译码线路、加大成本、多出一部分译码时间|
      |字段间接编码|某一个字段表示多个微命令组，<br>具体表示哪一组微命令由另一个字段确定|可进一步缩短微指令长度|译码线路复杂，时间开销大|
      |最短编码|整个微操作码部分作为一个字段，每次只产生一个微操作|操作码位数最少，长度最短|-|

      ```
      在字段直接编码中，互斥微操作组合在同一字段，相容微操作组合在不同字段。

      所谓相容微操作，指的是在数据通路中能同时进行的微操作，其对应的微命令称相容微命令。互斥微操作则是不能同时进行的微操作，对应的微命令称为互斥微命令。
      ```

   3. 水平型微指令和垂直型微指令：
      1. 水平型微指令：一条微指令能定义多个可并行的微命令。上述**不译法、字段直接编码字段间接编码编写的微指令是水平型微指令**。

      2. 垂直型微指令：一条微指令仅定义一个微命令。上述**最短编码编写的微指令是垂直型微指令**。
   4. 下一条微指令的地址的确定方式：
      1. 顺序-转移法（计数器法）：**下条微指令地址隐含在微程序计数器中**。
         ```
         顺序执行时，微PC自增1，得到下一条微地址指令；转移执行时，在当前微指令后添加一条转移微指令。
         ```

      2. 断定法（下址字段法）：当前微指令中**显式指定下条微指令地址**。
         ```
         一般来说断定法编写的微指令格式如下：[微命令字段][转移控制字段][下地址字段]
         ```

## 6. 流水线

一、流水线基本定义

1. 概念：是一种**时间上的并行技术**，使CPU可以并行多条指令以提高吞吐率。

2. 特点：
   1. 执行单个任务的时间开销**并不会缩短**。执行多个任务时单位时间内完成的任务数大大增加。

   2. 在**不改变单个任务执行时间的前提下**提高系统吞吐率。
3. 适合流水线的指令集：

二、流水线的性能指标

1. 流水线处理器执行时间
   1. 公式：$\bm{T_k = (k+n-1)\Delta t}$。

   2. 说明：k为流水线的段数，n为任务数(指令条数)。

2. 加速比：简单来说就是用流水线能快多少
   1. 公式：$\bm{S = \cfrac{T_0}{T_k} = \cfrac{kn\Delta t}{(k+n-1)\Delta t}}$

   2. 说明：当连续输入的任务数趋于无穷大时，最大加速比就是流水线的段数。

3. 吞吐率：单位时间内流水线完成的任务数量
   1. 基本公式：$\bm{T_p = \cfrac{n}{T_k}}$

   2. 公式：$\bm{T_p = \cfrac{n}{(k+n-1)\Delta t}}$
   3. 说明：当连续输入的任务数趋于无穷大时，最大吞吐率为：$T_{pmax} = \cfrac{1}{\Delta t}$

三、流水线冒险

1. 结构冒险(资源冲突)：
   1. 原因：多条指令在同一时刻占用同一资源

   3. 解决方法：
      - 专用部件：比如Cache拆**分为数据Cache和指令Cache**。

      - 插入气泡（指令间），暂停等待一个周期。
      - 插入NOP指令（指令间），使流水段延后一个周期执行。

   4. Load-use数据冒险的检测和处理
      - 定义：所谓Load-use冒险，就是**旁路无法解决的数据相关问题**。

      - 解决：一般来说由编译器进行优化。

2. 数据冒险
   1. 原因：主要包括三类，即**读后写，写后读，写后写**。

   2. 解决方法：
      - 硬件阻塞stall：硬件阻塞后续指令的执行，直到数据相关消除为止。
         ```
         从结果上看，stall和nop产生的效果一样，都增加了一样多的周期数。但是硬件阻塞的CPI更大，因为相同周期内执行的指令少了。
         ```

      - 软件插入NOP指令：在指令间插入NOP以延迟执行。注意**这里是插入一整行气泡**，而**不是结构冒险里面的一个流水段的气泡**。
      - 旁路：比如某些运算完成后先不写寄存器，下一条指令也不读寄存器，而是直接把**上一条指令的输出作为当前指令的输入**。

3. 控制冒险
   1. 原因：一般出现在改变指令执行顺序的情况，如**跳转、分支**等。

   2. 解决方法：
      - 分支预测：对**转移指令**进行分支预测，提前生成转移目标地址。包括两种，即**静态预测和动态预测**。
         > 静态预测：总是**预测分支条件不满足**，这时候**继续执行分支指令的后续指令**。如果预测错误，需要**丢弃三条本不该执行的指令**。
         > 实际做题的时候，丢弃的指令条数就是延迟槽的大小。

         > 动态预测：根据程序历史执行情况动态调整。转移发生的历史记录保存在特定的缓存中，有**分支历史记录表BHT、分支预测缓冲BPB、分支目标缓冲BTB**。在取指阶段就可以检测到。

      - 硬件阻塞stall：同数据冒险。
      - 软件插入NOP指令：同数据冒险。
      - 分支延迟：采用编译优化调整指令顺序，属于静态调度技术。