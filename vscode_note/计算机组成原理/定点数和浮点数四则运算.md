# <center> 四则运算 <center/>

## 1. 定点加、减法

1. 原码加减：
   1. 加法：同号相加，异号求差（大绝对值减小绝对值）。

   2. 减法：减数符号位取反，按加法规则运算。

2. 补码加减：$(A)_补 \pm (B)_补 = (A\pm B)_补$。

## 2. 定点乘、除法

1. 原码一位乘：
   1. 准备：符号位和数值位分开运算，先求出符号位。部分积带一位符号位。

   2. 步骤（$A \times B$）：
      - 部分积置零，乘数放入乘数寄存器。

      - 运算：若乘数寄存器末位为1，则部分积+A。若乘数寄存器末位为0，则部分积+0。若产生进位，进位位置1。
      - 右移：将进位位、部分积、乘数同步右移一位。
      - n位数需要进行n次`加法-右移`操作。最后一次右移结束后，结果为[部分积][乘数]。

2. 补码一位乘：
   1. 准备：**被乘数和部分积取两位符号位，乘数取一位符号位**。符号位都参与运算。

   2. 步骤（$A \times B$）：
      - 初始：部分积置零，乘数放入乘数寄存器，并附加一初始为0的符号位。

      - 判断和运算：当乘数最后一位和辅助位为00或11时，直接将部分及、乘数和辅助位**同步右移**。当乘数最后一位和辅助位为10时，乘数-A。当乘数最后一位和辅助位为01时乘数+A。
      - **n位数需要进行n+1步循环，但第n+1步时部分积不移位**。
        ```
        第n步时已经能获得正确的乘积。这里右移一位是为了使乘积的低位正确的存放在乘数寄存器的尾数中，使电路简单。
        ```
3. 原码恢复余数法：

4. 原码不恢复余数法：
   1. 准备：被除数和除数取两位符号位，商寄存器置0，取一位符号位。

   2. 步骤（$A \div B$）：
      - 初始：余数寄存器放入被除数，余数/商寄存器置0。

      - 第一步：试商，即A-B。
      - 判断和运算：**若余数为正，商1，余数左移一位，余数-B；若余数为负，商0，余数左移一位，余数+B**。
      - 最后一次运算若得到负数，则恢复一次余数，即余数+B。
      - n位数需要进行n+1次运算。
5. 补码加减交替除法：
   1. 准备：

   2. 步骤：
      - 初始：余数寄存器放入被除数，商寄存器置0。

      - 第一步：同号做减法，异号做加法。
      - 判断和运算：余数和除数同号商1，余数左移一位，做减法；异号商0，余数左移一位，做加法。
      - 最后一次运算完成后，商寄存器左移一位，空位按照最后一次运算的结果上商（同1异0）。
      - n位数进行n+1次运算和n次移位。
   3. 余数修正和商修正：同补码比较法。
6. 补码比较除法（booth法）：
   1. 准备：

   2. 步骤：
      - 初始：余数寄存器放入被除数，余数/商寄存器置0，商位留空。

      - 判断和运算：**若余数和除数同号商1，余数左移一位，余数-除数；异号商0，余数左移一位，余数+除数**。上商之前，商寄存器先左移再上商。
      - 重复上述操作，直到得到n + 1位商（n位除数）为止。
      - 商符取反，然后恢复余数和修正商。
   3. 余数修正：
      - 若除尽，则余数置0。

      - 若除不尽，**同号商负做减法，异号商正做加法**。
   4. 商数修正：
      - 若除尽，除数正商不修，除数负商加一。

      - 若除不尽，商正商不修，商负商加一。

## 3. 浮点四则

1. 浮点加减：
   1. 判0：位数为0，或浮点数阶码下溢。

   2. 对阶求阶差：小阶向大阶看齐。右移一位，阶码加1。对阶时隐藏位一起移动。
   3. 求和：补码加减法。
   4. 舍入与规格化：主要采取舍0入1法和恒置1法。

2. 浮点乘除：
   1. 浮点乘：
      - 准备：取双符号位。将两个操作数表示成补码形式。**注意要进行规格化**。

      - 判0，置积符：补码符号参与运算。
      - 阶码相加：按照补码加法规则运算。
      - 尾数相乘：按照补码一位乘法规则运算。
      - 规格化与舍入：这里注意**原码表示的规格化尾数和补码表示的规格化位数不一样**。
        ```
        原码：
            正数：0.1XXXXX
            负数：1.1XXXXX

        补码：
            正数：0.1XXXXX
            负数：1.0XXXXX

        其实二者本质相同，即要保证数据位的最高位是1。
        ```
   2. 浮点除：
      - 准备：取双符号位。将两个操作数表示为浮点数的规格化补码表示。

      - 判0，置商符。补码符号参与运算。 
      - 尾数调整：如果 $|M_A| \gt |M_B|$，则对A的尾数进行调整直到$|M_A| \lt |M_B|$
        ```
        尾数调整的目的：1.使定点除法的规则对于浮点除法也适用，即确保商符不被破坏。2.保证商为规格化的浮点数。
        ```
      - 阶码相减：按照补码减法规则运算。
      - 尾数相除：按照补码除法规则运算、修正。