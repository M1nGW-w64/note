# <center> 运算 <center/>

## 1. 基本运算

```
基本运算是计算机中最基本的操作单元，必须在一个时钟周期内完成。需要控制信号。且仅对寄存器中的数据进行运算。
```

1. 位运算：
   1. 按位与（A&B）：A & B = 1 当且仅当 A = B = 1。
      ```
      按位与的一个应用是使用掩码提取特定二进制位。原理简单来说就是按位与时只要有一个位为0，则结果必为0。
      ```

   2. 按位或（A|B）：A | B = 0 当且仅当 A = B = 0。
   3. 按位异或（A^B）：A、B相同异或结果为0，A、B不同异或结果为1。

2. 逻辑运算：
   1. 逻辑与（A && B）：当且仅当AB为True时结果为True。

   2. 逻辑或（A || B）：只要有一个为True时结果为True。
3. 移位运算：
   1. 无符号数：不管怎么移都是空位补0。

   2. 有符号数：
      - 原码：保持符号位不动，不管怎么移都是空位补0。

      - 补码：左移添0，右移添符号位。
      - 反码：正数移位添0，负数移位添1。
   ```
   即对无符号数进行逻辑移位，有符号数进行算术移位。
   ```
4. 位拓展和位截断运算
   ```
   当遇到短数向长数转换时，需要进行位拓展。当遇到长数向短数转换时，需要进行位截断。注意截断只会导致运算错误，而不会出现任何异常。
   ```
   1. 位拓展有两种，分别是零拓展（无符号数拓展）和符号拓展（有符号数拓展）。

   2. 对一个数进行截断，可能会因为**溢出**而改变它的值。**当一个长数大到短数无法表示时，进行截断就会溢出**。 

## 2. 定点数运算

一、加减法

1. **原码加减法**
   1. 减法：符号不论异同，被减数**符号位取反**，然后与减数求和，结果为原码。

   2. 加法：同号求和，符号不变；异号求差，大绝对值减小绝对值，符号取大绝对值，结果为原码。注意这里的减指的是二进制减法。
2. **补码加减法（符号位参与运算）**
   1. 加法直接算、减法变加法。

   2. 运算结果仍为补码，最高位进位丢弃。
3. 溢出和标志位
   1. 溢出位OF：计算机中带符号整数由补码表示。**异号运算不溢出，同号运算有可能溢出**。
      - **最高位的进位和次高位的进位不同，则溢出**。

      - **结果的符号与两个加数的符号不同，则溢出**。

   2. 符号位SF：运算结果（丢弃最高位的进位以后）的最高位，0正1负。对于无符号数运算该标志位没有意义。
   3. 零标志位ZF：当且仅当运算结果为0时ZF位置1。该标志位对于无符号数和带符号数都有意义。
   5. 进位标志为CF：表示无符号数的进位/借位。用于判断是否溢出。
   4. 双符号位：01表示正溢出，10表示负溢出，同号则表示不溢出。
   ```
   不管所给的数是否是无符号数，都按补码加减法来算。所谓有符号数、无符号数只是对机器数的解释不同而已。
   ```
   > 某机器字长8位，有一个8位加法器。有无符号数x=69和y=38，在加法器完成x-y的运算，则**该加法器的两个输入端信息和输入的低位进位信息**为？
   > 
   > [解答]：不管有符号还是无符号，加减运算都按补码加减法规则进行。由补码减法的公式，需将 $[y]_补$ 取反后再加1。**而实际实现上，先判断Sub的值，为0做加法，为1做减法。若做减法，先将y取反送入加法器，然后将sub作为低位进位送进加法器**。因此输入端信息为：0100 0101、11011001、1。

二、乘法

1. 原码一位乘法

   ```
   符号位异或（同号为正，异号为负）。数值部分绝对值相乘。原码一位乘主要涉及三个部件：乘积寄存器、乘数寄存器、进位位。

   注意，对于一个n位（不带符号位的操作数），运算过程中需要进行n次运算和n次右移。原码一位乘和列竖式手算其实是一样的。竖式是[上面不动，下面左移]，原码一位乘是[下面不动，上面右移]。
   ```
   1. 说明：
      - 原码一位乘和无符号数乘法本质相同，本质上就是一个东西。只不过前者需要判断符号位。

      - 进位位的作用：运算过程本质是无符号数的相加，无符号数相加有可能有溢出。所以需要进位位。
      - **初始：乘积寄存器置为0，乘数寄存器放乘数，进位位置为0。**

   2. **运算步骤**：
      - **运算：乘积（寄存器）+ 乘数（寄存器）最后一位 $\times$ 被乘数。** 若发生溢出则进位为置1。

      - 右移：将进位位、乘积（寄存器）、乘数（寄存器）**向右移逻辑右移一位**。移动时进位位一起移动（移出后补0**）
      - 结果：最后一次运算结束以后，按照 **[符号][乘积寄存器][乘数寄存器]** 的格式拼接。

2. 补码一位乘（booth法）

   ```
   符号位参与运算。运算结果也为补码。补码一位乘主要涉及两个部件：乘积寄存器、乘数寄存器。

   另外要注意的是，定点数乘数法不管整数还是小数，其运算都是一样的。本来机器数里面也没有小数点。
   ```

   1. 说明：
      - 补码一位乘的右移是**算术右移**（很好理解，因为是带符号数运算）。

      - **初始：乘积寄存器置为0（左），乘数寄存器放乘数（右，保留单符号位），乘数后面多加一位辅助位，辅助位初值为0。**
      - 实际运算中，当[乘数（寄存器）末位和辅助位]为11或00时，实际上是不加0的，下面写上加0是为了方便理解。

   2. **运算步骤**：
      - **运算：乘积（寄存器）+ [乘数（寄存器）末位和辅助位] $\times$ 被乘数**。**10相当于负数，也就是乘积（寄存器）+ 被乘数负数的补码；01相当于正数，也就是乘积（寄存器） + 被乘数的补码；00和11相当于0，也就是乘积（寄存器） + 0。**

      - 右移：将乘积（寄存器）、乘数（寄存器）**向右移算术右移一位**。
      - 结果：和于原码一位乘一样也是直接拼接。
   3. 溢出：补码乘法也会溢出。当A=B=-1时，C=1，这是唯一一种溢出情况。

三、除法

1. 原码除法——恢复余数法
   ```
   不论是恢复余数法还是不恢复余数法，运算的过程简单来说就是一个不断试商和判断的过程。试商的结果为负数，说明不够除，需要判断下一位。试商的结果为正数，说明够除，这时可以直接上商。

   下面的"初始"步骤中，是对定点小数运算而言的。如果是定点整数的除法，首先需要将n位的被除数进行符号拓展至2n位。拓展后，高n位放进余数寄存器，低n位放进余数/商寄存器中。
   ```
   1. 说明：
      - **初始：余数(寄存器)放入被除数，余数/商(寄存器)置0，商位留空。**

      - 下面所说的余数是为了便于理解，实际上指的是余数寄存器里面的内容。

   2. **运算步骤**：
      - 左移：将余数（寄存器）和余数/商（寄存器）左移一位。**第一次试商前不用移位。**

      - **运算：余数 - 除数。如果为负，商0，恢复余数（本质上是还原被除数）。如果为正，商1。**
      - 结果：运算中余数左移了n次，相当于放大了n倍。**真正的余数应该是余数寄存器的内容 * 2的负n次幂。**
   3. 循环次数：n位无符号数进行n次移位。

2. 原码除法——不恢复余数法
   ```
   不恢复余数法和恢复余数法的区别仅在于运算和结果这一步。不恢复余数法本质上就是把恢复余数法中，当被除数 - 除数为负时，进行的"恢复余数、移位、进行下一次试商"动作合并为一次加法完成。

   从不恢复余数法对结果的处理可以看出。不恢复余数法并不是真的不恢复余数。
   ```
   1. 说明：
      - **初始：余数（寄存器）放入被除数，余数/商（寄存器）置0，商位留空。**

      - 下面所说的被除数是为了方便理解，实际上指的是余数寄存器中的内容。

   2. **运算步骤**：
      - 左移：同恢复余数法。**第一次试商前不用移位。**

      - **运算：如果上一次试商的结果为负数，则被除数 + 除数。如果上一次试商的结果为正，则被除数 - 除数。被除数 $\pm$ 除数如果为负，商0。如果为正，商1。**
      - 结果：如果最后一次运算的结果为负，需要恢复余数（本质上是还原被除数）。
   3. 循环次数：n位无符号数需要循环n+1次，即第一次判断溢出+n次移位。

3. 补码除法
   ```
   涉及补码的运算一般先扩展为双符号位。
   ```
   1. 说明：
      - **初始：余数（寄存器）放入被除数，余数/商（寄存器）置0，商位留空**。

      - 下面所说的被除数是为了方便理解，实际上指的是余数寄存器中的内容。

   2. **运算步骤**：
      - 判断：**若余数（寄存器）和除数同号商1，异号商0**。上商之前，商寄存器先左移再上商。

      - 移位：余数往左移一位。
      - 运算：若商1，说明够减，则余数 - 除数。若商0，说明不够减，则余数 + 除数。
      - 重复上述操作，直到得到n + 1位商（n位除数）为止。
      - 商符取反，然后恢复余数和修正商。
   3. **余数的修正**：
         除尽|除不尽，商符0，余数除数异号|除不尽，商符1，余数除数同号|
         |:-:|:---------------------:|:---------------------:|
         |余数置0|余数+除数|余数-除数|
   4. **商的修正**：
         |除不尽，商为负<br>除尽，除数为负|除不尽，商为正<br>除尽，除数为正|
         |:-----------------------:|:-----------------------:|
         |商加1|不修正|
   5. 溢出：
      - 产生原因：被除数A的绝对值大于除数B的绝对值，即商绝对值大于1。

      - 对于除法运算器来说，当第一步够减即表示除法溢出。
      - 对于Booth除法来说，当某一步余数的两符号位异号时表示出发溢出。
      ```
      关于余数修正的理解：
      如果是正数除正数（负数除负数同理）除不尽，并且最后余数是负数，说明多减了一次（除数），因为正常来说正数除正数余数只能为正数；
      如果是负数除正数（正数除负数同理）除不尽，并且最后余数是正数，说明多加了一次（除数）。因为正常来说负数除正数余数只能为负数。
      ```
## 3. 浮点数运算

一、浮点数加减运算

1. 说明：
   1. **注意尾数用原码表示，阶码用移码表示。**

   2. **求阶差采用补码运算。**
   3. 如果尾数采用双符号位表示，则**第一位为符号位，第二位为隐藏位**。
      ```
      具体来说应该长这样：[符号位][隐藏位].[尾数]
      ```
2. 运算步骤：
   1. 对阶并求阶差：对阶规则为**小阶码向大阶码看齐**。对尾数右移时，需要**将隐藏位一起右移**，空出的地方补0。移出的位不能丢弃。

   2. 尾数求和：按**原码定点数**加法规则运算。运算时要带上符号位和小数点前的隐藏位。
   3. 规格化：**右移阶码加1，左移阶码减1**。
   4. 判断溢出：
      - 阶码上溢、阶码下溢：超过了可以表示的最大、最小值，机器将其当作 $\pm\infty$、0处理。

      - 尾数上溢、尾数下溢：尾数上溢可以通过右规补救。
      ```
      尾数下溢：尾数的最低有效位丢失。解决方案是进行舍入处理。并在运算过程中添加保护位。综上所述，浮点数是否溢出应该看阶码是否溢出。
      ```
   5. 舍入、置0：
      - 就近舍入：结果舍入为**最近可以表示的数**。具体来说就是添加两位附加位。附加位为01，则直接舍去，附加位为11,舍去后结果加1，附加位为10(中间值，则结果强制为偶数)。

      - `朝0舍入`、`正向舍入`、`负向舍入`：当附加位不为00时，结果朝`绝对值小的数` `正无穷方向` `负无穷方向`舍入。
      - **当尾数为0时说明结果为0，结果处理为机器零即可**。
      ```
      思考：为什么必须是小阶码向大阶码对齐？如果大阶向小阶对齐，左移以后有可能不再是定点小数，不符合规格化浮点数的要求。
      ```

二、浮点数乘法运算

1. 说明：

2. **运算步骤**：
   1. 尾数相乘，指数相加：
      - 指数相加：按照移码加法运算，即 $\bm{[x+y]_移 = x_移 + y_移 + 129}$ 。

      - 尾数相乘：数值和符号分开运算。**数值位按照无符号定点数乘法运算**。

   2. 尾数规格化：当两个操作数**均为规格化小数**时，运算得到的**尾数至多进行一次右规，不用进行左规**。
   3. 尾数舍入：舍入方式同浮点数加减。
   4. 溢出判断：
      - 指数上溢：指数全1，或x的指数和y的指数最高位为1，而x+y的结果最高位为0。

      - 指数下溢：指数全0，或x的指数和y的指数最高位为0，而x+y的结果最高位为1。
   ```
      浮点乘法指数上溢和下溢，无非就是负+负=正和正+正=负两种情况。
   ```

三、浮点数除法运算

1. 说明：
2. **运算步骤**：
   1. 尾数相除，指数相减：
      - 指数相减：按照移码减法运算，即 $\bm{[x-y]_移 = [x]_移 + [-[y]_移]_补 + 127}$（和浮点加减时进行的对阶类似，只不过最后要加127）。

      - 尾数相除：数值和符号分开运算。**数值位按照无符号定点数除法运算**。

   2. 尾数规格化：当两个操作数**均为规格化小数**时，运算得到的**尾数至多进行一次左规，不用进行右规**。
   3. 尾数舍入：舍入方式同浮点数加减。
   4. 溢出运算：
      - 指数上溢：指数全1，或x-y的结果和y的指数最高位为0且x的指数最高位为1。

      - 指数下溢：指数全1，或x-y的结果和y的指数最高位为1且x的指数最高位为0。
   ```
      浮点除法指数上溢和下溢，无非就是正-负=负和负-正=正两种情况。
   ```